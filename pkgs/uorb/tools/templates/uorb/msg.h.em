@###############################################
@#
@# Nextpilot ROS compatible message source code
@# generation for C++
@#
@# EmPy template for generating <msg>.h files
@# Based on the original template for ROS
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - search_path (dict) search paths for genmsg
@#  - topics (List of String) topic names
@###############################################

/*****************************************************************
 *     _   __             __   ____   _  __        __
 *    / | / /___   _  __ / /_ / __ \ (_)/ /____   / /_
 *   /  |/ // _ \ | |/_// __// /_/ // // // __ \ / __/
 *  / /|  //  __/_>  < / /_ / ____// // // /_/ // /_
 * /_/ |_/ \___//_/|_| \__//_/    /_//_/ \____/ \__/
 *
 * Copyright All Reserved Â© 2015-2024 NextPilot Development Team
 ******************************************************************/

/* Auto-generated by genmsg_cpp from file @file_name_in */

@{
import genmsg.msgs
import re

from generate_uorb_topic_helper import * # this is in Tools/

uorb_struct = '%s_s'%name_snake_case
uorb_struct_upper = name_snake_case.upper()
}@

#pragma once

@##############################
@# Generic Includes
@##############################

#include <uORB.h>

@##############################
@# Includes for dependencies
@##############################
@{
for field in spec.parsed_fields():
    if (not field.is_builtin):
        if (not field.is_header):
            (package, name) = genmsg.names.package_resource_name(field.base_type)
            package = package or spec.package # convert '' to package

            name = re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()
            print('#include <uORB/topics/%s.h>'%(name))
}@

@# Constants c style
#ifndef __cplusplus
@[for constant in spec.constants]@
#define @(uorb_struct_upper)_@(constant.name) @(int(constant.val))
@[end for]
#endif

@##############################
@# Main struct of message
@##############################
@{

def print_parsed_fields():
    # sort fields (using a stable sort)
    sorted_fields = sorted(spec.parsed_fields(), key=sizeof_field_type, reverse=True)
    struct_size, padding_end_size = add_padding_bytes(sorted_fields, search_path)
    # loop over all fields and print the type and name
    for field in sorted_fields:
        if (not field.is_header):
            print_field_def(field)
}@

#ifdef __cplusplus
@#class @(uorb_struct) {
struct __EXPORT @(uorb_struct) {
@#public:
#else
struct @(uorb_struct) {
#endif
@print_parsed_fields()

#ifdef __cplusplus
@# Constants again c++-ified
@{
for constant in spec.constants:
    type_name = constant.type
    if type_name in type_map:
        # need to add _t: int8 --> int8_t
        type_nfc = type_map[type_name]
    else:
        raise Exception("Type {0} not supported, add to to template file!".format(type_name))

    print('\tstatic constexpr %s %s = %s;'%(type_nfc, constant.name, int(constant.val)))
}
#endif
};

#ifdef __cplusplus
namespace nextpilot {
	namespace msg {
		using @(spec.short_name) = @(uorb_struct);
	} // namespace msg
} // namespace nextpilot
#endif

/* register this as object request broker structure */
@[for topic in topics]@
ORB_DECLARE(@topic);
@[end for]

#ifdef __cplusplus
void print_message(const orb_metadata *meta, const @uorb_struct& message);
#endif
